# -*- coding: utf-8 -*-
"""HTSims_v7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mMQZbZK35HtAq9OIROE6kseeYkqBO-C8
"""

"""
================================================================================
Thermal Analysis of a Nacelle (v6.1 - Refined Mount Path)
================================================================================
Purpose:
This version introduces the ESC Mount as a separate thermal node, modeling the
specific heat path from ESC -> Mount -> Battery Front. This adds a component
with thermal mass into the primary heat path for more realistic transient
behavior.
"""

# -------------------------
# 1. Import Necessary Libraries
# -------------------------
import time
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

start_time = time.time()
print('Conditions: Ambient Temperature = 293K, Ground Level (1 atm), HAP velocity = 0 m/s')

# -------------------------
# 2. Load and Prepare Air Properties
# -------------------------
path = "./298.xlsx"
df_air = pd.read_excel(path, sheet_name=1)
temperatures = df_air['Temperature (K)'].tolist(); rho_values   = df_air['Density (rho) kg/m3'].tolist()
cp_values    = df_air['Specific Heat (cp) J/kg.K'].tolist(); k_values     = df_air['Thermal Conductivity (k) W/m.K'].tolist()
mu_values    = df_air['Dynamic Viscosity (m)  kg/m.s'].tolist(); nu_values    = df_air['Kinematic Viscosity (n)  m2/s'].tolist()
Pr_values    = df_air['Prandtl Number (Pr)'].tolist()

def prop(T):
    r  = np.interp(T, temperatures, rho_values); cp = np.interp(T, temperatures, cp_values)
    k  = np.interp(T, temperatures, k_values); mu = np.interp(T, temperatures, mu_values)
    nu = np.interp(T, temperatures, nu_values); Pr = np.interp(T, temperatures, Pr_values)
    return r, cp, k, mu, nu, Pr

# -------------------------
# 3. Define Helper Functions for Physics Calculations
# -------------------------
def T_power4(T): return np.clip(T, 1e-6, 1e6)**4
def rad_coeff(e1, e2, a1, a2, vf):
    sigma = 5.67e-8
    return sigma / ((1 - e1) / (e1 * a1) + 1 / (a1 * vf) + (1 - e2) / (e2 * a2))

# -------------------------
# 4. Define System Constants and Geometry
# -------------------------
# Component Masses (kg)
m_B_total = 64.8; m_Bf = m_Bm = m_Br = m_B_total / 3
m_ESC = 0.12; m_TS  = 0.9; m_BS  = 0.9

# --- NEW: Mount Properties ---
m_mount = 0.050 # Mass of the mount (50g)
C_mount = 900   # Specific Heat of Aluminum (J/kg·K)
A_mount_conv = 0.01 # Convective surface area of the mount (m^2)
LC_mount = 0.05     # Characteristic length for mount convection (m)

# Component Specific Heat Capacities (J/kg·K)
C_B   = 1100; C_ESC = 100; C_TS  = 1040; C_BS  = 1040

# Internal Heat Generation (W)
Q_B_total = 232.8; Q_B_front = Q_B_middle = Q_B_rear = Q_B_total / 3
Q_ESC = 100
Q_S = 0; Q_A = 0; Q_P = 0

# Geometry and Conduction Coefficients
A_cross = 0.252 * 0.154; k_eff = 2.5; C_cond = k_eff * A_cross / 0.280
A_Bf_conv = 0.26617; A_Bm_conv = 0.22736; A_Br_conv = 0.26617
A_ESC_conv = 0.01348; A_TS = 0.54168; A_BS = 0.54168

# --- NEW: Updated Conduction Paths for ESC -> Mount -> Battery Front ---
# We assume aluminum (k=180) for mount conductivity and define interface geometry.
k_mount = 0.5
# Path 1: From ESC to Mount
A_contact_ESC_Mount = 0.05; L_path_ESC_Mount = 0.005
C_cond_ESC_to_Mount = k_mount * A_contact_ESC_Mount / L_path_ESC_Mount
# Path 2: From Mount to Battery Front
A_contact_Mount_Bf = 0.005; L_path_Mount_Bf = 0.005
C_cond_Mount_to_Bf = k_mount * A_contact_Mount_Bf / L_path_Mount_Bf
# NOTE: The direct path C_ESC_Bf_cond is now removed.

# Skin Conduction (internal to external shell surface)
k_cfrp = 0.015; A_cfrp = 0.54168; t_cfrp = 0.005; C_cond_cfrp = k_cfrp * A_cfrp / t_cfrp

# Radiation Coefficients
C_Bf_TS_int_rad = rad_coeff(0.9, 0.2, 0.0427, 0.54168, 1)
C_TS_BS_rad     = rad_coeff(0.2, 0.2, 0.54168, 0.54168, 0.5)
C_ESC_TS_rad    = rad_coeff(0.8, 0.2, 0.0013959, 0.54168, 1)
C_Bf_ESC_rad    = rad_coeff(0.2, 0.8, 0.038808, 0.00206415, 1)
C_Mount_rad     = rad_coeff(0.98, 0.2, A_mount_conv, A_TS, 1) # Simplified radiation from mount

# Characteristic Lengths (m)
LC_B_horiz = 0.277; LC_B_vert = 0.252; LC_ESC = 0.0695; LC_TS = LC_BS = 0.84

# Environmental Conditions
g = 9.81; velocity = 0.0; T_E = 298

# -------------------------
# 5. Define Convection Models
# -------------------------
def natural_convection_h(p_film, T_surface, T_fluid, L_char, is_vertical):
    k, Pr, nu_val = p_film[2], p_film[5], p_film[4]
    if abs(T_surface - T_fluid) < 1e-4: return 0.0
    T_film = (T_surface + T_fluid) / 2; beta = 1.0 / T_film
    Gr = (g * beta * abs(T_surface - T_fluid) * L_char**3) / (nu_val**2); Ra = Gr * Pr; Nu = 1.0
    if is_vertical: Nu = (0.825 + (0.387 * Ra**(1/6)) / (1 + (0.492 / Pr)**(9/16))**(8/27))**2
    else:
        if T_surface > T_fluid:
            if 1e4 <= Ra <= 1e7: Nu = 0.54 * Ra**(1/4)
            elif Ra > 1e7: Nu = 0.15 * Ra**(1/3)
        else:
            if 1e5 <= Ra <= 1e10: Nu = 0.27 * Ra**(1/4)
    return Nu * k / L_char

def forced_convection_h(p_film, L_char, velocity):
    k, Pr, rho, mu = p_film[2], p_film[5], p_film[0], p_film[3]
    Re_L = rho * velocity * L_char / max(mu, 1e-12);
    if Re_L < 100: return 0.0
    Re_crit = 5e5
    if Re_L <= Re_crit: Nu = 0.664 * (Re_L**0.5) * (Pr**(1/3))
    else: Nu = (0.037 * (Re_L**0.8) - 871) * (Pr**(1/3))
    return Nu * k / L_char

def get_external_surface_h(p_film, T_surface, T_fluid, L_char, velocity):
    if velocity > 0.1: return forced_convection_h(p_film, L_char, velocity)
    else: return natural_convection_h(p_film, T_surface, T_fluid, L_char, is_vertical=False)

# -------------------------
# 6. Define the System of ODEs
# -------------------------
def f(t, x):
    # Unpack the temperature array, now with 10 nodes
    T_Bf, T_Bm, T_Br, T_ESC, T_mount, T_TS_int, T_TS_ext, T_BS_int, T_BS_ext, T_air = x

    # --- Property Calculations ---
    p_air = prop(T_air); p_batt_film = prop((T_Bf + T_air) / 2); p_esc_film = prop((T_ESC + T_air) / 2)
    p_mount_film = prop((T_mount + T_air) / 2); p_ts_int_film = prop((T_TS_int + T_air) / 2)
    p_bs_int_film = prop((T_BS_int + T_air) / 2); p_ts_ext_film = prop((T_TS_ext + T_E) / 2)
    p_bs_ext_film = prop((T_BS_ext + T_E) / 2)
    T4_Bf, T4_Bm, T4_Br, T4_ESC, T4_mount, T4_TS_int, T4_BS_int = T_power4(np.array([T_Bf, T_Bm, T_Br, T_ESC, T_mount, T_TS_int, T_BS_int]))

    # --- Heat Flow Calculations ---
    # BATTERY NODES
    h_batt_avg = (natural_convection_h(p_batt_film, T_Bf, T_air, LC_B_horiz, False) * 2 + natural_convection_h(p_batt_film, T_Bf, T_air, LC_B_vert, True) * 2) / 4.0
    Q_conv_Bf = h_batt_avg * A_Bf_conv * (T_air - T_Bf); Q_conv_Bm = h_batt_avg * A_Bm_conv * (T_air - T_Bm); Q_conv_Br = h_batt_avg * A_Br_conv * (T_air - T_Br)
    Q_cond_Bf = C_cond * (T_Bm - T_Bf); Q_cond_Bm = C_cond * ((T_Bf - T_Bm) + (T_Br - T_Bm)); Q_cond_Br = C_cond * (T_Bm - T_Br)
    Q_rad_Bf = (C_Bf_TS_int_rad * (T4_TS_int - T4_Bf) + C_Bf_ESC_rad * (T4_ESC - T4_Bf) + C_Bf_TS_int_rad * (T4_BS_int - T4_Bf))
    Q_rad_Bm = (C_Bf_TS_int_rad * (T4_TS_int - T4_Bm) + C_Bf_TS_int_rad * (T4_BS_int - T4_Bm)); Q_rad_Br = (C_Bf_TS_int_rad * (T4_TS_int - T4_Br) + C_Bf_TS_int_rad * (T4_BS_int - T4_Br))
    # NEW: Conduction from Mount to Battery Front
    Q_cond_Mount_to_Bf = C_cond_Mount_to_Bf * (T_Bf - T_mount)

    # ESC
    Q_conv_ESC = natural_convection_h(p_esc_film, T_ESC, T_air, LC_ESC, False) * A_ESC_conv * (T_air - T_ESC)
    Q_rad_ESC = (C_Bf_ESC_rad * (T4_Bf - T4_ESC) + C_ESC_TS_rad * (T4_TS_int - T4_ESC) + C_ESC_TS_rad * (T4_BS_int - T4_ESC))
    # NEW: Conduction from ESC to Mount
    Q_cond_ESC_to_Mount = C_cond_ESC_to_Mount * (T_mount - T_ESC)

    # MOUNT
    Q_conv_Mount = natural_convection_h(p_mount_film, T_mount, T_air, LC_mount, False) * A_mount_conv * (T_air - T_mount)
    Q_rad_Mount = C_Mount_rad * (T4_TS_int - T4_mount) # Simplified: Assumes mount radiates to top shell

    # NACELLE SHELLS
    Q_cond_TS_ext = C_cond_cfrp * (T_TS_int - T_TS_ext); Q_cond_BS_ext = C_cond_cfrp * (T_BS_int - T_BS_ext)
    Q_conv_TS_in = natural_convection_h(p_ts_int_film, T_TS_int, T_air, LC_TS, False) * A_TS * (T_air - T_TS_int)
    Q_conv_TS_ext = get_external_surface_h(p_ts_ext_film, T_TS_ext, T_E, LC_TS, velocity) * A_TS * (T_E - T_TS_ext)
    Q_conv_BS_in = natural_convection_h(p_bs_int_film, T_BS_int, T_air, LC_BS, False) * A_BS * (T_air - T_BS_int)
    Q_conv_BS_ext = get_external_surface_h(p_bs_ext_film, T_BS_ext, T_E, LC_BS, velocity) * A_BS * (T_E - T_BS_ext)
    Q_rad_TS = (C_Bf_TS_int_rad * ((T4_Bf - T4_TS_int) + (T4_Bm - T4_TS_int) + (T4_Br - T4_TS_int)) + C_TS_BS_rad * (T4_BS_int - T4_TS_int)) + Q_rad_Mount # Top shell gains radiation from mount
    Q_rad_BS = (C_Bf_TS_int_rad * ((T4_Bf - T4_BS_int) + (T4_Bm - T4_BS_int) + (T4_Br - T4_BS_int)) + C_TS_BS_rad * (T4_TS_int - T4_BS_int))

    # INTERNAL AIR
    Q_conv_air = -(Q_conv_Bf + Q_conv_Bm + Q_conv_Br + Q_conv_ESC + Q_conv_Mount + Q_conv_TS_in + Q_conv_BS_in)
    V_a = 0.11; m_a = p_air[0] * V_a

    # --- Temperature Derivatives (dT/dt) ---
    # MODIFIED: Battery Front now gains conducted heat from the mount
    dT_Bf_dt     = (Q_B_front + Q_cond_Bf + Q_conv_Bf + Q_rad_Bf - Q_cond_Mount_to_Bf) / (m_Bf * C_B)
    dT_Bm_dt     = (Q_B_middle + Q_cond_Bm + Q_conv_Bm + Q_rad_Bm) / (m_Bm * C_B)
    dT_Br_dt     = (Q_B_rear + Q_cond_Br + Q_conv_Br + Q_rad_Br) / (m_Br * C_B)
    # MODIFIED: ESC now loses conducted heat to the mount
    dT_ESC_dt    = (Q_ESC + Q_conv_ESC + Q_rad_ESC + Q_cond_ESC_to_Mount) / (m_ESC * C_ESC)
    # NEW: The derivative for the mount node, balancing its heat flows
    dT_mount_dt  = (-Q_cond_ESC_to_Mount + Q_cond_Mount_to_Bf + Q_conv_Mount + Q_rad_Mount) / (m_mount * C_mount)
    # MODIFIED: Top shell no longer has a direct conduction path from mount
    dT_TS_int_dt = (-Q_cond_TS_ext + Q_conv_TS_in + Q_rad_TS) / (m_TS * C_TS)
    dT_TS_ext_dt = (Q_cond_TS_ext + Q_conv_TS_ext + Q_S) / (m_TS * C_TS)
    dT_BS_int_dt = (-Q_cond_BS_ext + Q_conv_BS_in + Q_rad_BS) / (m_BS * C_BS)
    dT_BS_ext_dt = (Q_cond_BS_ext + Q_conv_BS_ext + Q_A + Q_P) / (m_BS * C_BS)
    dT_air_dt    = Q_conv_air / (m_a * p_air[1])

    # Return the new 10-element array of derivatives
    return np.array([dT_Bf_dt, dT_Bm_dt, dT_Br_dt, dT_ESC_dt, dT_mount_dt, dT_TS_int_dt, dT_TS_ext_dt, dT_BS_int_dt, dT_BS_ext_dt, dT_air_dt])

# -------------------------
# 7. Set Up and Run the Simulation
# -------------------------
# Initial conditions now for 10 nodes
x0 = np.array([298.15] * 10)
print("Initial Temperatures (K):", x0)

t0 = 0; T_total = 3000000

class ProgressMonitor:
    def __init__(self, t_total): self.t_total = t_total; self.last_t = -1
    def __call__(self, t, y):
        if t - self.last_t >= 100:
            print(f"  ... Solving at time t = {int(t)} s ({100*t/self.t_total:.0f}%)")
            self.last_t = t
        return 0

progress_monitor = ProgressMonitor(T_total)
print(f"\nStarting solver for t = {t0} to {T_total} s...")
sol = solve_ivp(fun=f, t_span=[t0, T_total], y0=x0, method='BDF', dense_output=True, events=progress_monitor)
print("... Solver finished.")

# -------------------------
# 8. Process and Display Results
# -------------------------
final_temps = sol.y[:, -1]
# Labels list updated to include the mount
labels = ['Battery Front', 'Battery Middle', 'Battery Rear', 'ESC', 'ESC Mount', 'Top Shell Internal',
          'Top shell external', 'Bottom shell internal', 'Bottom Shell external', 'Internal Air']

print("\nFinal Temperatures (K):")
for lab, temp in zip(labels, final_temps):
    print(f"{lab:<25}: {temp:.2f} K")

end_time = time.time()
print(f"\nTotal execution time: {end_time - start_time:.2f} seconds")

# -------------------------
# 9. Plot the Results
# -------------------------
plt.figure(figsize=(14, 9))
t_plot = np.linspace(t0, T_total, 1000)
x_plot = sol.sol(t_plot).T
for i, lab in enumerate(labels):
    plt.plot(t_plot, x_plot[:, i], label=lab)

plt.xlabel('Time (s)', fontsize=12); plt.ylabel('Temperature (K)', fontsize=12)
plt.title('Transient Temperature Evolution of Nacelle Components (v6.1 with Mount)', fontsize=16)
plt.legend(loc='best', fontsize=10); plt.grid(True, which='both', linestyle='--', linewidth=0.5)
plt.tight_layout(); plt.show()