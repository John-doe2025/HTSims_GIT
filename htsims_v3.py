# -*- coding: utf-8 -*-
"""HTSims_v8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11t2OwooLI0PYvofAm60-kqsjXwUDFYaU
"""

# ==============================================================================
# Solar Data Fetcher for Thermal Simulation
# ==============================================================================
import requests
import pandas as pd
from datetime import datetime, timedelta

def fetch_and_save_solar_data(latitude, longitude, days, output_filename="solar_flux_data.csv"):
    """
    Fetches solar radiation forecast data from the Open-Meteo API and saves it
    to a CSV file formatted for the thermal simulation.

    Args:
        latitude (float): Latitude of the location for the simulation.
        longitude (float): Longitude of the location for the simulation.
        days (int): How many days of forecast data to fetch from today.
        output_filename (str): The name of the output CSV file.
    """
    print(f"--- Starting Data Fetch for {days} days at ({latitude}, {longitude}) ---")

    # 1. Prepare the API request parameters
    base_url = "https://api.open-meteo.com/v1/forecast"
    start_date = datetime.now().strftime("%Y-%m-%d")
    end_date = (datetime.now() + timedelta(days=days - 1)).strftime("%Y-%m-%d")

    params = {
        "latitude": latitude,
        "longitude": longitude,
        "start_date": start_date,
        "end_date": end_date,
        "hourly": "shortwave_radiation",  # Global Horizontal Irradiance (GHI) in W/m^2
        "timezone": "auto"
    }

    # 2. Make the API call
    print(f"Querying Open-Meteo API for solar flux from {start_date} to {end_date}...")
    try:
        response = requests.get(base_url, params=params)
        response.raise_for_status()
    except requests.exceptions.RequestException as e:
        print(f"Error: API call failed. {e}")
        return

    data = response.json()
    print("API call successful. Processing data...")

    # 3. Process the data using pandas
    if 'hourly' not in data or 'time' not in data['hourly']:
        print("Error: The received data does not contain the expected 'hourly' data.")
        return

    df = pd.DataFrame(data['hourly'])
    df['time'] = pd.to_datetime(df['time'])

    # Calculate 'time_seconds': elapsed time in seconds from the first timestamp
    start_time_obj = df['time'].iloc[0]
    df['time_seconds'] = (df['time'] - start_time_obj).dt.total_seconds()

    # Rename the column for clarity in the main simulation
    df.rename(columns={"shortwave_radiation": "flux_w_m2"}, inplace=True)

    # 4. Create the final DataFrame and save to CSV
    output_df = df[['time_seconds', 'flux_w_m2']]
    try:
        output_df.to_csv(output_filename, index=False)
        print(f"\nSuccess! Data saved to '{output_filename}'")
        print(f"Total data points fetched: {len(output_df)}")
        print(f"Data covers time from {start_time_obj} onwards.")
    except IOError as e:
        print(f"Error: Could not write to file '{output_filename}'. {e}")

if __name__ == "__main__":
    # --- Configuration ---
    # Location for your UAV's operation (NAL, Bangalore)
    LATITUDE = 12.9586
    LONGITUDE = 77.653

    # Fetch n days of data. This provides a full 24-hour cycle for looping.
    DAYS_TO_FETCH = 15

    # Run the main function
    fetch_and_save_solar_data(LATITUDE, LONGITUDE, DAYS_TO_FETCH)

"""
================================================================================
Thermal Analysis of a Nacelle
================================================================================
Purpose:
This script performs a transient thermal analysis of a nacelle. It now includes
optional, time-varying external radiation loads and has been updated to simulate
conditions at a 20 km altitude with rarefied air.
"""

# -------------------------
# 1. Import Necessary Libraries
# -------------------------
import time
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy.integrate import solve_ivp

start_time = time.time()

# -------------------------
# 2. Load and Prepare All Physical Data
# -------------------------
path = "./298.xlsx"
df_air = pd.read_excel(path, sheet_name=1)
temperatures = df_air['Temperature (K)'].tolist()
rho_values = df_air['Density (rho) kg/m3'].tolist()
cp_values = df_air['Specific Heat (cp) J/kg.K'].tolist()
k_values = df_air['Thermal Conductivity (k) W/m.K'].tolist()
mu_values = df_air['Dynamic Viscosity (m)  kg/m.s'].tolist()
nu_values = df_air['Kinematic Viscosity (n)  m2/s'].tolist()
Pr_values = df_air['Prandtl Number (Pr)'].tolist()

print("Loading pre-fetched solar data from solar_flux_data.csv...")
try:
    df_solar = pd.read_csv("solar_flux_data.csv")
    solar_time_data = df_solar['time_seconds'].tolist()
    solar_flux_data = df_solar['flux_w_m2'].tolist()
    print("Solar data loaded successfully.")
except FileNotFoundError:
    print("\n!!! WARNING: solar_flux_data.csv not found. Solar flux will be zero. !!!")
    solar_time_data = [0, 86400]; solar_flux_data = [0, 0]

# -------------------------
# 3. Define Helper Functions for Physics Calculations
# -------------------------
def prop(T):
    # Interpolate properties from sea-level data
    r_sl = np.interp(T, temperatures, rho_values)
    cp = np.interp(T, temperatures, cp_values)
    k = np.interp(T, temperatures, k_values)
    mu = np.interp(T, temperatures, mu_values)
    nu = np.interp(T, temperatures, nu_values)
    Pr = np.interp(T, temperatures, Pr_values)
    # Apply a correction factor for density at 20km altitude
    r = r_sl * DENSITY_FACTOR
    return r, cp, k, mu, nu, Pr

def T_power4(T): return np.clip(T, 1e-6, 1e6)**4
def rad_coeff(e1, e2, a1, a2, vf):
    sigma = 5.67e-8; return sigma / ((1 - e1) / (e1 * a1) + 1 / (a1 * vf) + (1 - e2) / (e2 * a2))

def get_solar_flux(t):
    data_period_seconds = solar_time_data[-1]
    if data_period_seconds <= 0: return 0
    effective_time = t + start_offset_seconds
    lookup_time = effective_time % data_period_seconds
    return np.interp(lookup_time, solar_time_data, solar_flux_data)

# -------------------------
# 4. Define System Constants and Geometry
# -------------------------
ENABLE_EXTERNAL_RADIATION = True
SIMULATION_START_HOUR = 8.0
start_offset_seconds = SIMULATION_START_HOUR * 3600.0

# --- NEW: Altitude-Specific Environmental Parameters ---
T_E = 216.7                     # Ambient temperature at 20 km [K]
velocity = 20                   # Aircraft velocity [m/s]
DENSITY_FACTOR = 0.07      # Density of air at 20km is ~7% of sea level

# External Radiation Parameters
FLUX_ALBEDO_FRACTION = 0.3
FLUX_PLANETARY = 237.0
ALPHA_SOLAR = 0.6
EPSILON_IR = 0.8

# Masses, Specific Heats, and Internal Generation
m_B_total = 64.8
m_Bf = m_Bm = m_Br = m_B_total / 3
m_ESC = 0.12
m_TS = m_BS = 0.9
C_B = 1100
C_ESC = 100
C_TS = C_BS = 1040
Q_B_total = 232.8
Q_B_front = Q_B_middle = Q_B_rear = Q_B_total / 3
Q_ESC = 100

# Geometry and Conduction
A_cross = 0.252 * 0.154; k_eff = 2.5; C_cond = k_eff * A_cross / 0.280
A_Bf_conv = 0.26617; A_Bm_conv = 0.22736; A_Br_conv = 0.26617
A_ESC_conv = 0.01348; A_TS = 0.54168; A_BS = 0.54168
k_cfrp = 1.0; A_cfrp = 0.54168; t_cfrp = 0.0005; C_cond_cfrp = k_cfrp * A_cfrp / t_cfrp
k_mount = 3; A_contact = 0.005; L_mount = 0.005; C_ESC_Bf_cond = k_mount * A_contact / L_mount

# Internal Radiation Coefficients
C_Bf_TS_int_rad = rad_coeff(0.9, 0.05, 0.0427, 0.54168, 1)
C_TS_BS_rad = rad_coeff(0.05, 0.05, 0.54168, 0.54168, 0.5)
C_ESC_TS_rad = rad_coeff(0.8, 0.05, 0.0013959, 0.54168, 1)
C_Bf_ESC_rad = rad_coeff(0.9, 0.8, 0.038808, 0.00206415, 1)

# Characteristic Lengths (m) & Gravity
LC_B_horiz = 0.277; LC_B_vert = 0.252; LC_ESC = 0.0695; LC_TS = LC_BS = 0.840; g = 9.81

# Print initial conditions using the variables just defined
print("\n--- Simulation Initial Conditions ---")
print(f"Altitude: 20 km")
print(f"Ambient Temperature: {T_E} K")
print(f"Aircraft Velocity: {velocity} m/s")
print(f"External Radiation Model Enabled: {ENABLE_EXTERNAL_RADIATION}")
if ENABLE_EXTERNAL_RADIATION: print(f"Simulation Start Time: {SIMULATION_START_HOUR}:00 (Hour of Day)")
print("-------------------------------------\n")

# -------------------------
# 5. Define Convection Models
# -------------------------
def natural_convection_h(p_film, T_surface, T_fluid, L_char, is_vertical):
    k, Pr, nu_val = p_film[2], p_film[5], p_film[4]
    if abs(T_surface - T_fluid) < 1e-4: return 0.0
    T_film = (T_surface + T_fluid) / 2; beta = 1.0 / T_film
    Gr = (g * beta * abs(T_surface - T_fluid) * L_char**3) / (nu_val**2); Ra = Gr * Pr; Nu = 1.0
    if is_vertical: Nu = (0.825 + (0.387 * Ra**(1/6)) / (1 + (0.492 / Pr)**(9/16))**(8/27))**2
    else:
        if T_surface > T_fluid:
            if 1e4 <= Ra <= 1e7: Nu = 0.54 * Ra**(1/4)
            elif Ra > 1e7: Nu = 0.15 * Ra**(1/3)
        else:
            if 1e5 <= Ra <= 1e10: Nu = 0.27 * Ra**(1/4)
    return Nu * k / L_char

def forced_convection_h(p_film, L_char, velocity):
    k, Pr, rho, mu = p_film[2], p_film[5], p_film[0], p_film[3]
    Re_L = rho * velocity * L_char / max(mu, 1e-12);
    if Re_L < 100: return 0.0
    Re_crit = 5e5
    if Re_L <= Re_crit: Nu = 0.664 * (Re_L**0.5) * (Pr**(1/3))
    else: Nu = (0.037 * (Re_L**0.8) - 871) * (Pr**(1/3))
    return Nu * k / L_char

def get_external_surface_h(p_film, T_surface, T_fluid, L_char, velocity):
    if velocity > 0.1: return forced_convection_h(p_film, L_char, velocity)
    else: return natural_convection_h(p_film, T_surface, T_fluid, L_char, is_vertical=False)

# -------------------------
# 6. Define the System of ODEs
# -------------------------
def f(t, x):
    T_Bf, T_Bm, T_Br, T_ESC, T_TS_int, T_TS_ext, T_BS_int, T_BS_ext, T_air = x
    p_air = prop(T_air); p_batt_film = prop((T_Bf + T_air) / 2); p_esc_film = prop((T_ESC + T_air) / 2)
    p_ts_int_film = prop((T_TS_int + T_air) / 2); p_bs_int_film = prop((T_BS_int + T_air) / 2)
    p_ts_ext_film = prop((T_TS_ext + T_E) / 2); p_bs_ext_film = prop((T_BS_ext + T_E) / 2)

    if ENABLE_EXTERNAL_RADIATION:
        current_solar_flux = get_solar_flux(t)
        sigma = 5.67e-8

        # Scenario B: Top shell sees the sun and sky; Bottom shell sees the Earth.
        # --- Top Shell External Heat Loads (looking up) ---
        Q_solar_in_TS = current_solar_flux * A_TS * ALPHA_SOLAR
        Q_albedo_in_TS = 0.0 # No view of Earth, so no albedo
        Q_planetary_in_TS = 0.0 # No view of Earth, so no planetary IR
        T4_TS_ext = T_power4(T_TS_ext)
        Q_rad_to_sky_TS = -sigma * A_TS * EPSILON_IR * T4_TS_ext # Radiates to cold sky (VF=1)

        # --- Bottom Shell External Heat Loads (looking down) ---
        Q_solar_in_BS = 0.0 # Assumed to be shaded
        albedo_flux = current_solar_flux * FLUX_ALBEDO_FRACTION
        Q_albedo_in_BS = albedo_flux * A_BS * ALPHA_SOLAR
        Q_planetary_in_BS = FLUX_PLANETARY * A_BS * EPSILON_IR
        Q_rad_to_earth_BS = -sigma * A_BS * EPSILON_IR * (T_power4(T_BS_ext) - T_power4(T_E)) # Radiates to Earth
    else:
        Q_solar_in_TS = Q_albedo_in_TS = Q_planetary_in_TS = Q_rad_to_sky_TS = 0.0
        Q_solar_in_BS = Q_albedo_in_BS = Q_planetary_in_BS = Q_rad_to_earth_BS = 0.0

    # Internal Heat Transfers... (no changes here)
    h_batt_avg = (natural_convection_h(p_batt_film, T_Bf, T_air, LC_B_horiz, False) * 2 + natural_convection_h(p_batt_film, T_Bf, T_air, LC_B_vert, True) * 2) / 4.0
    Q_conv_Bf = h_batt_avg * A_Bf_conv * (T_air - T_Bf); Q_conv_Bm = h_batt_avg * A_Bm_conv * (T_air - T_Bm); Q_conv_Br = h_batt_avg * A_Br_conv * (T_air - T_Br)
    Q_cond_Bf = C_cond * (T_Bm - T_Bf); Q_cond_Bm = C_cond * ((T_Bf - T_Bm) + (T_Br - T_Bm)); Q_cond_Br = C_cond * (T_Bm - T_Br)
    T4_Bf, T4_Bm, T4_Br, T4_ESC, T4_TS_int, T4_BS_int = T_power4(np.array([T_Bf, T_Bm, T_Br, T_ESC, T_TS_int, T_BS_int]))
    Q_rad_Bf = (C_Bf_TS_int_rad*(T4_TS_int - T4_Bf) + C_Bf_ESC_rad*(T4_ESC - T4_Bf) + C_Bf_TS_int_rad*(T4_BS_int - T4_Bf))
    Q_rad_Bm = (C_Bf_TS_int_rad*(T4_TS_int - T4_Bm) + C_Bf_TS_int_rad*(T4_BS_int - T4_Bm))
    Q_rad_Br = (C_Bf_TS_int_rad*(T4_TS_int - T4_Br) + C_Bf_TS_int_rad*(T4_BS_int - T4_Br))
    Q_conv_ESC = natural_convection_h(p_esc_film, T_ESC, T_air, LC_ESC, False) * A_ESC_conv * (T_air - T_ESC)
    Q_rad_ESC = (C_Bf_ESC_rad*(T4_Bf - T4_ESC) + C_ESC_TS_rad*(T4_TS_int - T4_ESC) + C_ESC_TS_rad*(T4_BS_int - T4_ESC))
    Q_cond_ESC_Bf = C_ESC_Bf_cond * (T_ESC - T_Bf); Q_cond_TS_ext = C_cond_cfrp * (T_TS_int - T_TS_ext)
    Q_cond_BS_ext = C_cond_cfrp * (T_BS_int - T_BS_ext)
    Q_conv_TS_in = natural_convection_h(p_ts_int_film, T_TS_int, T_air, LC_TS, False) * A_TS * (T_air - T_TS_int)
    Q_conv_TS_ext = get_external_surface_h(p_ts_ext_film, T_TS_ext, T_E, LC_TS, velocity) * A_TS * (T_E - T_TS_ext)
    Q_conv_BS_in = natural_convection_h(p_bs_int_film, T_BS_int, T_air, LC_BS, False) * A_BS * (T_air - T_BS_int)
    Q_conv_BS_ext = get_external_surface_h(p_bs_ext_film, T_BS_ext, T_E, LC_BS, velocity) * A_BS * (T_E - T_BS_ext)
    Q_rad_TS = (C_Bf_TS_int_rad * ((T4_Bf - T4_TS_int) + (T4_Bm - T4_TS_int) + (T4_Br - T4_TS_int)) + C_TS_BS_rad * (T4_BS_int - T4_TS_int))
    Q_rad_BS = (C_Bf_TS_int_rad * ((T4_Bf - T4_BS_int) + (T4_Bm - T4_BS_int) + (T4_Br - T4_BS_int)) + C_TS_BS_rad * (T4_TS_int - T4_BS_int))
    Q_conv_air = -(Q_conv_Bf + Q_conv_Bm + Q_conv_Br + Q_conv_ESC + Q_conv_TS_in + Q_conv_BS_in)
    m_a = prop(T_air)[0] * 0.11

    # --- Temperature Derivatives ---
    dT_Bf_dt = (Q_B_front + Q_cond_Bf + Q_conv_Bf + Q_rad_Bf + Q_cond_ESC_Bf) / (m_Bf * C_B)
    dT_Bm_dt = (Q_B_middle + Q_cond_Bm + Q_conv_Bm + Q_rad_Bm) / (m_Bm * C_B)
    dT_Br_dt = (Q_B_rear + Q_cond_Br + Q_conv_Br + Q_rad_Br) / (m_Br * C_B)
    dT_ESC_dt = (Q_ESC + Q_conv_ESC + Q_rad_ESC - Q_cond_ESC_Bf) / (m_ESC * C_ESC)
    dT_TS_int_dt = (-Q_cond_TS_ext + Q_conv_TS_in + Q_rad_TS) / (m_TS * C_TS)
    dT_TS_ext_dt = (Q_cond_TS_ext + Q_conv_TS_ext + Q_solar_in_TS + Q_albedo_in_TS + Q_planetary_in_TS + Q_rad_to_sky_TS) / (m_TS * C_TS)
    dT_BS_int_dt = (-Q_cond_BS_ext + Q_conv_BS_in + Q_rad_BS) / (m_BS * C_BS)
    dT_BS_ext_dt = (Q_cond_BS_ext + Q_conv_BS_ext + Q_solar_in_BS + Q_albedo_in_BS + Q_planetary_in_BS + Q_rad_to_earth_BS) / (m_BS * C_BS)
    dT_air_dt = Q_conv_air / (m_a * p_air[1])
    return np.array([dT_Bf_dt, dT_Bm_dt, dT_Br_dt, dT_ESC_dt, dT_TS_int_dt, dT_TS_ext_dt, dT_BS_int_dt, dT_BS_ext_dt, dT_air_dt])

# --- Sections 7, 8, 8a, and 9 remain identical to the previous version ---
# (Code for running the simulation, analyzing results, and plotting)
# ... (rest of the script)
# -------------------------
# 7. Set Up and Run the Simulation
# -------------------------
x0 = np.array([298.15] * 9); t0 = 0; T_total = 2628000 # 30 days
class ProgressMonitor:
    def __init__(self, t_total): self.t_total = t_total; self.last_t = -1
    def __call__(self, t, y):
        if t - self.last_t >= 3600: print(f"  ... Solving at Day {t/86400:.1f} ({100*t/self.t_total:.1f}%)"); self.last_t = t
        return 0

progress_monitor = ProgressMonitor(T_total)
print(f"Starting solver for t = {t0} to {T_total/86400:.1f} days...")
sol = solve_ivp(fun=f, t_span=[t0, T_total], y0=x0, method='BDF', dense_output=True, events=progress_monitor)
print("... Solver finished.")

# -------------------------
# 8. Process and Display Results
# -------------------------
final_temps = sol.y[:, -1]
labels = ['Battery Front', 'Battery Middle', 'Battery Rear', 'ESC', 'Top Shell Internal',
          'Top shell external', 'Bottom shell internal', 'Bottom Shell external', 'Internal Air']
print("\n--- Final Temperatures (at end of simulation) ---")
for lab, temp in zip(labels, final_temps):
    print(f"{lab:<25}: {temp:.2f} K")

# -------------------------
# 8a. Post-Simulation Analysis (NEW SECTION)
# -------------------------
print("\n--- In-Depth Thermal Analysis ---")
analysis_window_days = 3
if T_total / 86400 > analysis_window_days: analysis_start_time = T_total - (analysis_window_days * 86400)
else: analysis_start_time = 0
t_analysis = np.linspace(analysis_start_time, T_total, 2000)
x_analysis = sol.sol(t_analysis)
print(f"Analyzing last {analysis_window_days} days of simulation for cyclical peaks/lows:")
for i, lab in enumerate(labels):
    temp_history = x_analysis[i, :]
    min_temp = np.min(temp_history); max_temp = np.max(temp_history)
    temp_swing = max_temp - min_temp
    print(f"{lab:<25}: Peak = {max_temp:.2f} K | Min = {min_temp:.2f} K | Swing = {temp_swing:.2f} K")

end_time = time.time()
print(f"\nTotal execution time: {end_time - start_time:.2f} seconds")

# -------------------------
# 9. Plot the Results
# -------------------------
plt.figure(figsize=(14, 9))
t_plot = np.linspace(t0, T_total, 2000)
x_plot = sol.sol(t_plot).T
for i, lab in enumerate(labels):
    plt.plot(t_plot / 86400, x_plot[:, i], label=lab)
plt.xlabel('Time (Days)', fontsize=12); plt.ylabel('Temperature (K)', fontsize=12)
plt.title('Transient Temperature Evolution of Nacelle Components (20km Altitude)', fontsize=16)
plt.legend(loc='best', fontsize=10); plt.grid(True, which='both', linestyle='--', linewidth=0.5)
plt.tight_layout(); plt.show()